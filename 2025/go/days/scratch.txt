
package days

import (
	"bufio"
	"bytes"
	"log"
)

type Day4 struct{}

type Point struct {
	row int
	col int
}

func RunDay4(input []byte) {
	day := new(Day4)
	log.Printf("D4P1: %d", day.part1(input))
	log.Printf("D4P2: %d", day.part2(input))
}

func (*Day4) part1(input []byte) int {
	scanner := bufio.NewScanner(bytes.NewReader(input))
	grid := make([][]bool, 1)
	rowLength := -1
	rowNum := 1
	for scanner.Scan() {
		line := scanner.Text()
		if rowLength < 0 {
			rowLength = len(line) + 2
			grid[0] = make([]bool, rowLength)
		}

		grid = append(grid, make([]bool, rowLength))
		grid[rowNum] = make([]bool, rowLength)
		for idx, point := range line {
			if point == '@' {
				grid[rowNum][idx+1] = true
			}
		}
		rowNum++
	}
	grid = append(grid, make([]bool, rowLength))
	grid[rowNum] = make([]bool, rowLength)

	return movePapers(grid, false, 0)
}

func (*Day4) part2(input []byte) int {
	scanner := bufio.NewScanner(bytes.NewReader(input))
	grid := make([][]bool, 1)
	rowLength := -1
	rowNum := 1
	for scanner.Scan() {
		line := scanner.Text()
		if rowLength < 0 {
			rowLength = len(line) + 2
			grid[0] = make([]bool, rowLength)
		}

		grid = append(grid, make([]bool, rowLength))
		grid[rowNum] = make([]bool, rowLength)
		for idx, point := range line {
			if point == '@' {
				grid[rowNum][idx+1] = true
			}
		}
		rowNum++
	}
	grid = append(grid, make([]bool, rowLength))
	grid[rowNum] = make([]bool, rowLength)

	return movePapers(grid, true, 0)
}

func movePapers(grid [][]bool, recurse bool, moved int) int {
	markedForRemoval := make([]Point, 0)
	for rnum, col := range grid {
		for cnum := range col {
			if grid[rnum][cnum] {
				neighbours := 0
				if grid[rnum-1][cnum-1] {
					neighbours++
				}
				if grid[rnum-1][cnum] {
					neighbours++
				}
				if grid[rnum-1][cnum+1] {
					neighbours++
				}
				if grid[rnum][cnum-1] {
					neighbours++
				}
				if grid[rnum][cnum+1] {
					neighbours++
				}
				if grid[rnum+1][cnum-1] {
					neighbours++
				}
				if grid[rnum+1][cnum] {
					neighbours++
				}
				if grid[rnum+1][cnum+1] {
					neighbours++
				}
				if neighbours < 4 {
					markedForRemoval = append(markedForRemoval, Point{row: rnum, col: cnum})
				}
			}
		}
	}

	for _, point := range markedForRemoval {
		log.Printf("ðŸªµNBY point: %v NBY\n", point)
		grid[point.row][point.col] = false
		moved++
	}
	log.Printf("-----------------REMOVED %d pieces of paper----------------------", len(markedForRemoval))

	if recurse && len(markedForRemoval) > 0 {
		return movePapers(grid, recurse, moved)
	}
	return moved
}
